# TypeScript Best Practices & Type Safety Rules

## üîí Type Safety Enforcement

### MUST DO:

- **ALWAYS** use strict TypeScript configuration
- **ALWAYS** define explicit return types for functions
- **ALWAYS** use proper generic types for reusable functions
- **ALWAYS** handle null/undefined cases explicitly

### NEVER DO:

- ‚ùå Use `any` type without proper type guards
- ‚ùå Ignore TypeScript compiler errors
- ‚ùå Use type assertions (`as`) without validation
- ‚ùå Create functions without proper error handling

## üèóÔ∏è Interface Design Patterns

### MUST DO:

```typescript
// ‚úÖ CORRECT - Proper interface design
export interface User {
  id: number;
  username: string;
  email?: string; // Optional properties clearly marked
  created_at?: string;
  updated_at?: string;
}

export interface ApiResponse<T> {
  data: T;
  message?: string;
  status: number;
}

export interface PaginatedResponse<T> {
  count: number;
  next: string | null;
  previous: string | null;
  results: T[];
}
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
interface User {
  id: any; // Don't use any
  username: string;
  [key: string]: any; // Don't use index signatures without constraints
}
```

## üîß Component Props Patterns

### MUST DO:

```typescript
// ‚úÖ CORRECT - Well-defined component props
export interface ButtonProps {
  children: ReactNode;
  onClick?: () => void;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  className?: string;
  type?: 'button' | 'submit' | 'reset';
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  disabled = false,
  type = 'button',
  ...props
}) => {
  // Component implementation
};
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
const Button = (props: any) => {
  // Don't use any
  // Implementation
};

const Button = ({ children, ...rest }: any) => {
  // Don't use any
  // Implementation
};
```

## üõ†Ô∏è Utility Function Patterns

### MUST DO:

```typescript
// ‚úÖ CORRECT - Type-safe utility functions
export const formatRelativeTime = (date: string | Date): string => {
  const now = new Date();
  const targetDate = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - targetDate.getTime()) / 1000);

  if (diffInSeconds < 60) return 'Î∞©Í∏à Ï†Ñ';
  // ... more logic
};

export const setStorageItem = <T>(key: string, value: T): void => {
  try {
    const serializedValue = JSON.stringify(value);
    localStorage.setItem(key, serializedValue);
  } catch (error) {
    console.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÄÏû• Ïã§Ìå®:', error);
  }
};

export const getStorageItem = <T>(key: string, defaultValue?: T): T | null => {
  try {
    const item = localStorage.getItem(key);
    if (item === null) {
      return defaultValue || null;
    }
    return JSON.parse(item);
  } catch (error) {
    console.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÏùΩÍ∏∞ Ïã§Ìå®:', error);
    return defaultValue || null;
  }
};
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
export const formatTime = (date: any): any => {
  // Don't use any
  // Implementation
};

export const saveToStorage = (key: string, value: any): void => {
  // Don't use any
  localStorage.setItem(key, JSON.stringify(value));
};
```

## üîç Type Guards & Validation

### MUST DO:

```typescript
// ‚úÖ CORRECT - Type guards for runtime validation
export const isValidEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const isUser = (obj: unknown): obj is User => {
  return obj !== null && typeof obj === 'object' && 'id' in obj && 'username' in obj;
};

export const validatePassword = (
  password: string,
): {
  isValid: boolean;
  errors: string[];
} => {
  const errors: string[] = [];

  if (password.length < 8) {
    errors.push('ÎπÑÎ∞ÄÎ≤àÌò∏Îäî ÏµúÏÜå 8Ïûê Ïù¥ÏÉÅÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.');
  }

  if (!/[A-Z]/.test(password)) {
    errors.push('ÎπÑÎ∞ÄÎ≤àÌò∏Îäî ÎåÄÎ¨∏ÏûêÎ•º Ìè¨Ìï®Ìï¥Ïïº Ìï©ÎãàÎã§.');
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
};
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
export const validateEmail = (email: any): boolean => {
  // Don't use any
  return email.includes('@');
};

export const checkUser = (user: any): boolean => {
  // Don't use any
  return user && user.name;
};
```

## üéØ Error Handling Patterns

### MUST DO:

```typescript
// ‚úÖ CORRECT - Proper error handling with types
export const safeApiCall = async <T>(
  apiFunction: () => Promise<T>,
): Promise<{ data: T | null; error: string | null }> => {
  try {
    const data = await apiFunction();
    return { data, error: null };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return { data: null, error: errorMessage };
  }
};

export const handleAsyncError = async <T>(promise: Promise<T>): Promise<T> => {
  try {
    return await promise;
  } catch (error) {
    console.error('Async operation failed:', error);
    throw new Error('Operation failed');
  }
};
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
export const apiCall = async (func: any): Promise<any> => {
  // Don't use any
  try {
    return await func();
  } catch (error) {
    console.log(error); // Don't just log errors
    return null;
  }
};
```

## üîÑ State Management Types

### MUST DO:

```typescript
// ‚úÖ CORRECT - Proper state management types
export interface AppState {
  user: User | null;
  loading: boolean;
  error: string | null;
}

export interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (user: User) => void;
  logout: () => void;
  accessToken: string;
  setAccessToken: (token: string) => void;
}

export type Action =
  | { type: 'SET_USER'; payload: User }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'LOGOUT' };
```

### NEVER DO:

```typescript
// ‚ùå WRONG - Avoid these patterns
export interface State {
  user: any; // Don't use any
  loading: any;
  error: any;
}

export type Action = any; // Don't use any
```

## üö® Critical TypeScript Rules

### IMMEDIATE ACTIONS REQUIRED:

1. **NEVER** use `any` type without proper type guards
2. **ALWAYS** define explicit return types for functions
3. **ALWAYS** handle null/undefined cases explicitly
4. **ALWAYS** use proper generic types for reusable functions
5. **NEVER** ignore TypeScript compiler errors

### ENFORCEMENT:

- All functions MUST have explicit return types
- All component props MUST have proper TypeScript interfaces
- All API responses MUST have proper type definitions
- All error handling MUST include proper type checking
- All utility functions MUST use generics for type safety
  description:
  globs:
  alwaysApply: false

---
